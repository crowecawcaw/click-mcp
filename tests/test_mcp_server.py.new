import subprocess
import sys
from pathlib import Path

import pytest

from mcp import stdio
from mcp.client import ClientSession


@pytest.fixture
async def mcp_server_client(
    request,
    script_path: Path,
    cli_cmd: str = "mcp",
    server_params: str = "",
):
    # Make a copy of the test script to allow concurrent tests
    script_copy = script_path.with_suffix(f".{request.node.name}.py")
    script_copy.write_text(script_path.read_text())

    async with stdio_client(server_params) as (read, write):
        async with ClientSession(
            read=read, write=write, command=[sys.executable, str(script_copy), cli_cmd]
        ) as session:
            yield session
            script_copy.unlink()


@pytest.fixture(params=["asyncio"])
def anyio_backend():
    return "asyncio"


@pytest.fixture
async def basic_mcp_session(request):
    """Fixture that provides an MCP client connected to a basic server."""
    script_path = Path(__file__).parent / "basic_cli.py"

    async with mcp_server_client(script_path, "mcp") as session:
        yield session


@pytest.fixture
async def advanced_mcp_session(request):
    """Fixture that provides an MCP client connected to an advanced server."""
    script_path = Path(__file__).parent / "advanced_cli.py"

    async with mcp_server_client(script_path, "start-mcp") as session:
        yield session


@pytest.mark.anyio
async def test_basic_server_tools(basic_mcp_session):
    """Test that the basic MCP server returns correct tools."""
    result = await basic_mcp_session.list_tools()

    # Check that we have tools
    assert result is not None
    assert hasattr(result, "tools")
    tools = result.tools
    assert len(tools) > 0

    # Find the greet command
    greet_tool = None
    for tool in tools:
        if "greet" in tool.name.lower():
            greet_tool = tool
            break

    assert greet_tool is not None
    # Verify inputSchema structure
    assert "properties" in greet_tool.inputSchema
    schema_properties = greet_tool.inputSchema["properties"]
    assert "name" in schema_properties

    # Get properties of name parameter
    name_param = schema_properties["name"]
    assert "type" in name_param
    assert "description" in name_param

    # Find the users_list command
    users_list_tool = None
    for tool in tools:
        if "users_list" in tool.name.lower():
            users_list_tool = tool
            break

    assert users_list_tool is not None
    # Verify inputSchema structure - should be empty
    assert "properties" in users_list_tool.inputSchema
    assert len(users_list_tool.inputSchema["properties"]) == 0

    # Find the echo command
    echo_tool = None
    for tool in tools:
        if "echo" in tool.name.lower():
            echo_tool = tool
            break

    assert echo_tool is not None
    # Verify positional arguments are handled correctly
    assert "text" in echo_tool.inputSchema.get("properties", {})
    assert echo_tool.inputSchema["required"] == ["text"]


@pytest.mark.anyio
async def test_invoke_greet_command(basic_mcp_session):
    """Test invoking the greet command."""
    # Get tools
    result = await basic_mcp_session.list_tools()
    tools = result.tools

    # Find the greet command
    greet_tool = None
    for tool in tools:
        if "greet" in tool.name.lower():
            greet_tool = tool
            break

    assert greet_tool is not None

    # Invoke the command
    result = await basic_mcp_session.call_tool(greet_tool.name, {"name": "User"})

    assert result is not None
    assert len(result.content) > 0
    assert "Hello, User!" in result.content[0].text


@pytest.mark.anyio
async def test_invoke_users_list_command(basic_mcp_session):
    """Test invoking the users.list command."""
    # Get tools
    result = await basic_mcp_session.list_tools()
    tools = result.tools

    # Find the users_list command
    users_list_tool = None
    for tool in tools:
        if "users_list" in tool.name.lower():
            users_list_tool = tool
            break

    assert users_list_tool is not None

    # Invoke the command
    result = await basic_mcp_session.call_tool(users_list_tool.name, {})

    assert result is not None
    assert len(result.content) > 0
    assert "User1\nUser2\nUser3" in result.content[0].text


@pytest.mark.anyio
async def test_invoke_echo_command(basic_mcp_session):
    """Test invoking the echo command."""
    # Get tools
    result = await basic_mcp_session.list_tools()
    tools = result.tools

    # Find the echo command
    echo_tool = None
    for tool in tools:
        if "echo" in tool.name.lower():
            echo_tool = tool
            break

    assert echo_tool is not None

    # Test that positional arguments are passed correctly
    result = await basic_mcp_session.call_tool(echo_tool.name, {"text": "Hello, World!"})

    assert result is not None
    assert len(result.content) > 0
    assert "Hello, World!" in result.content[0].text


@pytest.mark.anyio
async def test_error_handling(basic_mcp_session):
    """Test error handling."""
    # Using an invalid tool name should fail gracefully
    with pytest.raises(Exception):
        await basic_mcp_session.call_tool("not.a.real.command", {})


@pytest.mark.anyio
async def test_advanced_server_tools(advanced_mcp_session):
    """Test that the advanced MCP server returns correct tools."""
    result = await advanced_mcp_session.list_tools()

    # Check that we have tools
    assert result is not None
    assert hasattr(result, "tools")
    tools = result.tools
    assert len(tools) > 0

    # Find the config_set command
    config_set_tool = None
    for tool in tools:
        if "config_set" in tool.name.lower():
            config_set_tool = tool
            break

    assert config_set_tool is not None
    # Verify inputSchema structure
    assert "properties" in config_set_tool.inputSchema
    schema_properties = config_set_tool.inputSchema["properties"]
    assert "key" in schema_properties
    assert "value" in schema_properties

    # Find the greet command to test subgroups
    greet_tool = None
    for tool in tools:
        if "greet" in tool.name.lower():
            greet_tool = tool
            break

    assert greet_tool is not None
    # Verify tool structure
    assert "properties" in greet_tool.inputSchema
    assert hasattr(greet_tool, "name")


@pytest.fixture
async def custom_server_name_session(request):
    """Fixture that provides an MCP client connected to a server with custom name."""
    script_path = Path(__file__).parent / "custom_server_cli.py"

    async with mcp_server_client(script_path, "mcp") as session:
        yield session


@pytest.mark.anyio
async def test_custom_server_name(custom_server_name_session):
    """Test that the custom MCP server name is recognized."""
    result = await custom_server_name_session.list_tools()

    # Check that we have tools
    assert result is not None
    assert hasattr(result, "tools")
    tools = result.tools

    assert len(tools) == 1
    assert tools[0].name == "greet"


@pytest.mark.anyio
async def test_invoke_advanced_commands(advanced_mcp_session):
    """Test invoking commands on the advanced CLI."""
    # Get tools
    result = await advanced_mcp_session.list_tools()
    tools = result.tools

    # Find the config_set command
    config_set_tool = None
    for tool in tools:
        if "config_set" in tool.name.lower():
            config_set_tool = tool
            break

    assert config_set_tool is not None

    # Try using multiple subcommand variations
    for params in [
        {"key": "name", "value": "test"},
        {"key": "color", "value": "blue"},
    ]:
        result = await advanced_mcp_session.call_tool(config_set_tool.name, params)
        assert result is not None